{"version":3,"file":"PFDUtils.js","sourceRoot":"","sources":["../../../pfd/components/PFDUtils.tsx"],"names":[],"mappings":"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","sourcesContent":["import { Arinc429Word } from '../shared/arinc429';\r\nimport { getSmallestAngle } from '../shared/utils';\r\nimport { DisplayComponent, EventBus, FSComponent, NodeReference, Subject, Subscribable, VNode } from 'msfssdk';\r\nimport { HeadingBug } from './horizon';\r\nimport { PFDSimvars } from '../shared/PFDSimvarPublisher';\r\n\r\nexport const calculateHorizonOffsetFromPitch = (pitch: number) => {\r\n    if (pitch > -5 && pitch <= 20) {\r\n        return pitch * 1.8;\r\n    } if (pitch > 20 && pitch <= 30) {\r\n        return -0.04 * pitch ** 2 + 3.4 * pitch - 16;\r\n    } if (pitch > 30) {\r\n        return 20 + pitch;\r\n    } if (pitch < -5 && pitch >= -15) {\r\n        return 0.04 * pitch ** 2 + 2.2 * pitch + 1;\r\n    }\r\n    return pitch - 8;\r\n};\r\n\r\nexport const calculateVerticalOffsetFromRoll = (roll: number) => {\r\n    let offset = 0;\r\n\r\n    if (Math.abs(roll) > 60) {\r\n        offset = Math.max(0, 41 - 35.87 / Math.sin(Math.abs(roll) / 180 * Math.PI));\r\n    }\r\n    return offset;\r\n};\r\n\r\ninterface HorizontalTapeProps {\r\n    displayRange: number;\r\n    valueSpacing: number;\r\n    distanceSpacing: number;\r\n    //graduationElementFunction: (elementHeading: number, offset: number) => JSX.Element;\r\n    bugs: [number][];\r\n    yOffset?: number;\r\n    bus: EventBus;\r\n}\r\n\r\nexport class HorizontalTape extends DisplayComponent<HorizontalTapeProps> {\r\n\r\n    private refElement = FSComponent.createRef<SVGGElement>();\r\n\r\n    private refElement2 = FSComponent.createRef<SVGGElement>();\r\n\r\n\r\n\r\n    private currentHeading: number = 0;\r\n\r\n  \r\n    private buildGraduationElements(): SVGGElement[] {\r\n        const headingTicks: SVGGElement[] = [];\r\n      \r\n\r\n        const numTicks = 72;//Math.round(this.props.displayRange * 100 / this.props.valueSpacing);\r\n\r\n      /*   let leftmostHeading = Math.round((this.currentHeading - this.props.displayRange) / this.props.valueSpacing) * this.props.valueSpacing;\r\n        if (leftmostHeading < this.currentHeading - this.props.displayRange) {\r\n            leftmostHeading += this.props.valueSpacing;\r\n        } */\r\n\r\n        // FIXME\r\n        let leftmostHeading = 0;\r\n    \r\n    \r\n        for (let i = 0; i < numTicks; i++) {\r\n\r\n            let text = '';\r\n            let classText = '';\r\n            let tickLength = 3.8302;\r\n            let textYPos: number | undefined;\r\n\r\n            const elementHeading = leftmostHeading + i * this.props.valueSpacing;\r\n            const offset = elementHeading * this.props.distanceSpacing / this.props.valueSpacing;\r\n\r\n            \r\n        const roundedHeading = Math.round(elementHeading);\r\n        //console.log(roundedHeading);\r\n        if (roundedHeading % 10 === 0) {\r\n            if (roundedHeading % 30 === 0) {\r\n                classText = 'FontMedium';\r\n                textYPos = 154.64206;\r\n            } else {\r\n                classText = 'FontSmallest';\r\n                textYPos = 154.27985;\r\n            }\r\n            let textVal = Math.round(elementHeading / 10) % 36;\r\n            if (textVal < 0) {\r\n                textVal += 36;\r\n            }\r\n            text = textVal.toString();\r\n        } else {\r\n            tickLength *= 0.42;\r\n        }\r\n\r\n        const tickRef = FSComponent.createRef<SVGGElement>();\r\n            headingTicks.push(<g id=\"HeadingTick\" ref={tickRef} transform={`translate(${offset} 0)`}>\r\n                <path class=\"NormalStroke White\" d={`m68.913 145.34v${tickLength}`} />\r\n                <text id=\"HeadingLabel\" class={`White MiddleAlign ${classText}`} x=\"68.879425\" y={textYPos}>{text}</text>\r\n           \r\n             </g>)\r\n        }\r\n\r\n        return headingTicks;\r\n    }\r\n\r\n    onAfterRender(node: VNode): void {\r\n        super.onAfterRender(node);\r\n\r\n        const pf = this.props.bus.getSubscriber<PFDSimvars>();\r\n\r\n        pf.on('heading').whenChanged().handle(h => {\r\n            const newVal = new Arinc429Word(h);\r\n           // this.currentHeading = newVal.value;\r\n           //console.log(newVal.value);\r\n           const offset = -newVal.value * this.props.distanceSpacing / this.props.valueSpacing;\r\n\r\n\r\n           let offset2 = -newVal.value * this.props.distanceSpacing / this.props.valueSpacing;\r\n           //calced from 40 degrees (~ the range of the tape)\r\n           if(Math.abs(offset) <= 60.44) {\r\n               //calced from 360 degrees\r\n               offset2 = -543.6 + offset;\r\n           } else {\r\n               offset2 += 543.6;\r\n           }\r\n            this.refElement.instance.setAttribute('transform',`translate(${offset} 0)`)\r\n            this.refElement2.instance.setAttribute('transform',`translate(${offset2} 0)`)\r\n\r\n        })\r\n\r\n    }\r\n\r\n    render(): VNode {\r\n\r\n\r\n    const numTicks = Math.round(this.props.displayRange * 2 / this.props.valueSpacing);\r\n\r\n/*     let leftmostHeading = Math.round((this.props.heading.value - this.props.displayRange) / this.props.valueSpacing) * this.props.valueSpacing;\r\n    if (leftmostHeading < this.props.heading.value - this.props.displayRange) {\r\n        leftmostHeading += this.props.valueSpacing;\r\n    } */\r\n\r\n    //const graduationElements: JSX.Element[] = [];\r\n    const bugElements: number[] = [];\r\n\r\n/*     for (let i = 0; i < numTicks; i++) {\r\n        const elementHeading = leftmostHeading + i * this.props.valueSpacing;\r\n        const offset = elementHeading * this.props.distanceSpacing / this.props.valueSpacing;\r\n        //graduationElements.push(graduationElementFunction(elementHeading, offset));\r\n    }\r\n */\r\n/*     this.props.bugs.forEach((currentElement) => {\r\n        const angleToZero = getSmallestAngle(this.props.heading.value, 0);\r\n        const smallestAngle = getSmallestAngle(currentElement[0], 0);\r\n        let offset = currentElement[0];\r\n        if (Math.abs(angleToZero) < 90 && Math.abs(smallestAngle) < 90) {\r\n            if (angleToZero > 0 && smallestAngle < 0) {\r\n                offset = currentElement[0] - 360;\r\n            } else if (angleToZero < 0 && smallestAngle > 0) {\r\n                offset = currentElement[0] + 360;\r\n            }\r\n        }\r\n\r\n        offset *= this.props.distanceSpacing / this.props.valueSpacing;\r\n        bugElements.push(offset);\r\n    }); */\r\n\r\n        return (\r\n            <>\r\n            <g ref={this.refElement}>\r\n                {/* {graduationElements} */}\r\n                {this.buildGraduationElements()}\r\n               \r\n                {bugElements.forEach(offet => {\r\n                    <HeadingBug offset={offet}/>\r\n                })}\r\n            </g>\r\n             <g ref={this.refElement2}>\r\n             {/* {graduationElements} */}\r\n             {this.buildGraduationElements()}\r\n            \r\n             {bugElements.forEach(offet => {\r\n                 <HeadingBug offset={offet}/>\r\n             })}\r\n         </g>\r\n         </>\r\n        );\r\n    }\r\n   \r\n}\r\n\r\ninterface VerticalTapeProps {\r\n    displayRange: number;\r\n    valueSpacing: number;\r\n    distanceSpacing: number;\r\n    bugs: [(offset: number) => SVGElement, number][];\r\n    tapeValue: Subscribable<number>;\r\n    lowerLimit?: number;\r\n    upperLimit?: number;\r\n    type: 'altitude' | 'speed';\r\n}\r\n\r\nexport class VerticalTape extends DisplayComponent<VerticalTapeProps> {\r\n\r\n    private refElement = FSComponent.createRef<SVGGElement>();\r\n\r\n    private buildSpeedGraduationPoints(): NodeReference<SVGGElement>[] {\r\n        const numTicks = Math.round(this.props.displayRange * 100 / this.props.valueSpacing);\r\n           \r\n        let lowestValue = 30;\r\n\r\n        if (lowestValue < this.props.tapeValue.get() - this.props.displayRange) {\r\n            lowestValue += this.props.valueSpacing;\r\n        }\r\n    \r\n\r\n        const graduationPoints = [];\r\n\r\n                for (let i = 0; i < numTicks; i++) {\r\n                    const elementValue = lowestValue + i * this.props.valueSpacing;\r\n                    if (elementValue <= (this.props.upperLimit ??  Infinity)) {\r\n                        const offset = -elementValue * this.props.distanceSpacing / this.props.valueSpacing;\r\n                        const element = {elementValue, offset};\r\n                        if (element) {\r\n                            //console.log(\"ADDING\", elementValue);\r\n                            //this.refElement.instance.append(<this.props.graduationElementFunction offset={offset} alt={elementValue} />);\r\n    \r\n                            if (elementValue < 30) {\r\n                                return <></>;\r\n                            }\r\n                        \r\n                            let text = '';\r\n                            if (elementValue % 20 === 0) {\r\n                                text = Math.abs(elementValue).toString().padStart(3, '0');\r\n                            }\r\n                        \r\n                            \r\n                            graduationPoints.push( <g transform={`translate(0 ${offset})`}>\r\n                            <path class=\"NormalStroke White\" d=\"m19.031 80.818h-2.8206\" />\r\n                            <text class=\"FontMedium MiddleAlign White\" x=\"7.7348943\" y=\"82.936722\">{text}</text>\r\n                        </g>);\r\n                    }\r\n                }\r\n            }   \r\n            return graduationPoints;\r\n    }\r\n\r\n    private buildAltitudeGraduationPoints(): NodeReference<SVGGElement>[] {\r\n        const numTicks = Math.round(this.props.displayRange * 100 / this.props.valueSpacing);\r\n\r\n\r\n           \r\n        const lowestValue = 0;\r\n        const graduationPoints = [];\r\n\r\n                for (let i = 0; i < numTicks; i++) {\r\n                    const elementValue = lowestValue + i * this.props.valueSpacing;\r\n                    if (elementValue <= (this.props.upperLimit ??  Infinity)) {\r\n                        const offset = -elementValue * this.props.distanceSpacing / this.props.valueSpacing;\r\n                        const element = {elementValue, offset};\r\n                        if (element) {\r\n                            //console.log(\"ADDING\", newValue.value);\r\n                            //this.refElement.instance.append(<this.props.graduationElementFunction offset={offset} alt={elementValue} />);\r\n    \r\n                            let text = '';\r\n                            let isText = false;\r\n                            if (elementValue % 500 === 0) {\r\n                                isText = true;\r\n                                text = (Math.abs(elementValue) / 100).toString().padStart(3, '0');\r\n                            }\r\n                        \r\n       \r\n                            \r\n                            graduationPoints.push(<g transform={`translate(0 ${offset})`}>\r\n                                {text &&\r\n                                     <path class=\"NormalStroke White\" d=\"m115.79 81.889 1.3316-1.0783-1.3316-1.0783\" />}          \r\n                            <path class=\"NormalStroke White\" d=\"m130.85 80.819h-2.0147\" />\r\n                            <text class=\"FontMedium MiddleAlign White\" x=\"122.98842\" y=\"82.939713\">{text}</text>\r\n                        </g>);\r\n                    }\r\n                }\r\n            }   \r\n            return graduationPoints;\r\n    }\r\n\r\n\r\n    onAfterRender(node: VNode): void {\r\n        super.onAfterRender(node);\r\n        this.props.tapeValue.sub(a => {\r\n\r\n\r\n\r\n            const newValue = new Arinc429Word(a);\r\n\r\n            const clampedValue = Math.max(Math.min(newValue.value, this.props.upperLimit ?? Infinity), this.props.lowerLimit ?? -Infinity);\r\n    \r\n            let lowestValue = 30;//Math.max(Math.round((clampedValue - this.props.displayRange) / this.props.valueSpacing) *this.props. valueSpacing, this.props.lowerLimit??-Infinity);\r\n            if (lowestValue < newValue.value - this.props.displayRange) {\r\n                lowestValue += this.props.valueSpacing;\r\n            }\r\n\r\n            this.refElement.instance.setAttribute('transform', `translate(0 ${clampedValue * this.props.distanceSpacing / this.props.valueSpacing})`);\r\n\r\n           \r\n        });\r\n    }\r\n   \r\n\r\n    render(): VNode {\r\n        \r\n\r\n        const bugElements: number[] = [];\r\n    \r\n     \r\n    \r\n     /*    this.props.bugs.forEach((currentElement) => {\r\n            const value = currentElement[0];\r\n            const offset = -value * this.props.distanceSpacing / this.props.valueSpacing;\r\n            bugElements.push(offset);\r\n        }); */\r\n        return (\r\n            <g ref={this.refElement}>\r\n                {this.props.type === 'altitude' && this.buildAltitudeGraduationPoints()}\r\n                {this.props.type === 'speed' && this.buildSpeedGraduationPoints()}\r\n                {this.props.children}\r\n             {/*   {this.graduationElements.sub(leThing => {\r\n                   leThing.forEach(v => {\r\n                    <graduationElementFunction offset={v.offset} alt={v.elementValue} />\r\n                   })\r\n               })}  */}\r\n              {/*  {bugElements.forEach(offet => {\r\n                    <HeadingBug offset={offet}/>\r\n                })} */}\r\n            </g>\r\n        );\r\n    }\r\n   \r\n};\r\n\r\n/* export const BarberpoleIndicator = (\r\n    tapeValue: number, border: number, isLowerBorder: boolean, displayRange: number,\r\n    element: (offset: number) => JSX.Element, elementSize: number,\r\n) => {\r\n    const Elements: [(offset: number) => JSX.Element, number][] = [];\r\n\r\n    const sign = isLowerBorder ? 1 : -1;\r\n    const isInRange = isLowerBorder ? border <= tapeValue + displayRange : border >= tapeValue - displayRange;\r\n    if (!isInRange) {\r\n        return Elements;\r\n    }\r\n    const numElements = Math.ceil((border + sign * tapeValue - sign * (displayRange + 2)) / elementSize);\r\n    for (let i = 0; i < numElements; i++) {\r\n        const elementValue = border + sign * elementSize * i;\r\n        Elements.push([element, elementValue]);\r\n    }\r\n\r\n    return Elements;\r\n}; */\r\n\r\nexport const SmoothSin = (origin: number, destination: number, smoothFactor: number, dTime: number) => {\r\n    if (origin === undefined) {\r\n        return destination;\r\n    }\r\n    if (Math.abs(destination - origin) < Number.EPSILON) {\r\n        return destination;\r\n    }\r\n    const delta = destination - origin;\r\n    let result = origin + delta * Math.sin(Math.min(smoothFactor * dTime, 1.0) * Math.PI / 2.0);\r\n    if ((origin < destination && result > destination) || (origin > destination && result < destination)) {\r\n        result = destination;\r\n    }\r\n    return result;\r\n};\r\n\r\nexport class LagFilter {\r\n    private PreviousInput: number;\r\n\r\n    private PreviousOutput: number;\r\n\r\n    private TimeConstant: number;\r\n\r\n    constructor(timeConstant: number) {\r\n        this.PreviousInput = 0;\r\n        this.PreviousOutput = 0;\r\n\r\n        this.TimeConstant = timeConstant;\r\n    }\r\n\r\n    reset() {\r\n        this.PreviousInput = 0;\r\n        this.PreviousOutput = 0;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param input Input to filter\r\n     * @param deltaTime in seconds\r\n     * @returns {number} Filtered output\r\n     */\r\n    step(input: number, deltaTime: number): number {\r\n\r\n     \r\n\r\n        const filteredInput = !Number.isNaN(input) ? input : 0;\r\n\r\n        const scaledDeltaTime = deltaTime * this.TimeConstant;\r\n        const sum0 = scaledDeltaTime + 2;\r\n\r\n        const output = (filteredInput + this.PreviousInput) * scaledDeltaTime / sum0\r\n            + (2 - scaledDeltaTime) / sum0 * this.PreviousOutput;\r\n\r\n        this.PreviousInput = filteredInput;\r\n\r\n        if (Number.isFinite(output)) {\r\n            this.PreviousOutput = output;\r\n            return output;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n\r\nexport class RateLimiter {\r\n    private PreviousOutput: number;\r\n\r\n    private RisingRate: number;\r\n\r\n    private FallingRate: number;\r\n\r\n    constructor(risingRate: number, fallingRate: number) {\r\n        this.PreviousOutput = 0;\r\n\r\n        this.RisingRate = risingRate;\r\n        this.FallingRate = fallingRate;\r\n    }\r\n\r\n    step(input: number, deltaTime: number) {\r\n        const filteredInput = !Number.isNaN(input) ? input : 0;\r\n\r\n        const subInput = filteredInput - this.PreviousOutput;\r\n\r\n        const scaledUpper = deltaTime * this.RisingRate;\r\n        const scaledLower = deltaTime * this.FallingRate;\r\n\r\n        const output = this.PreviousOutput + Math.max(Math.min(scaledUpper, subInput), scaledLower);\r\n        this.PreviousOutput = output;\r\n        return output;\r\n    }\r\n}\r\n"]}